// Test stealing is an opt-in feature that allows you to take a single
// test module and spawn many test runner subprocesses that do work stealing
// when you call `test`. Test stealing is enabled
// by overriding `def testEnableWorkStealing`, as shown below:

//// SNIPPET:BUILD1
package build
import mill._, scalalib._

object foo extends ScalaModule {
  def scalaVersion = "2.13.8"
  object test extends ScalaTests {
    def ivyDeps = Seq(ivy"com.lihaoyi::utest:0.8.5")
    def testFramework = "utest.runner.Framework"
    
    def testEnableWorkStealing = true
  }
}


//// SNIPPET:END

// In this example, we have one test module `foo.test`, and a bunch of test classes in test/src folder.
// By default, all test classes will run sequentially in the same JVM, but with `testEnableWorkStealing`
// we can set up a cluster of JVM subprocesses that do work stealing on those test classes, all run in parallel,
// and each will have its own separate `sandbox` folder and `.log` file:

/** Usage

> mill -j 3 foo.test # Can be flaky, but the test time will be big enough for cluster do decide to spawn all test runners

> find out/foo/test/testForked.dest
...
out/foo/test/testForked.dest/0.log
out/foo/test/testForked.dest/0
out/foo/test/testForked.dest/1.log
out/foo/test/testForked.dest/1
out/foo/test/testForked.dest/2.log
out/foo/test/testForked.dest/2
out/foo/test/testForked.dest/selectors
out/foo/test/testForked.dest/test-report.xml
...

*/

// Test stealing allows you to run tests in parallel while keeping things deterministic and
// debuggable: parallel test groups will not write over each others files in their
// sandbox, and each one will have a separate set of logs that can be easily read
// without the others mixed in
//
// By the nature of work stealing, you can run tests in parallel without worrying about fast/slow tests
//
// Test stealing can be use in combination with test grouping. In that case, test subprocesses will never
// steal tests from different groups.
