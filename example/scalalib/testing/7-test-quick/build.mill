// Millâ€™s `testQuick` command enables efficient, fine-grained selective test execution for JVM projects.
// Between run, Mill leverages it's bytecode analysis to determine which test classes are potentially impacted by recent code changes,
// and executes only those tests. If a test fails, it will continue to be executed on future runs until it passes, regardless of further code changes.

//// SNIPPET:BUILD1
package build
import mill._, scalalib._
import os._

object foo extends ScalaModule {
  def scalaVersion = "2.13.8"
  object test extends ScalaTests {
    def mvnDeps = Seq(mvn"com.lihaoyi::utest:0.8.5")
    def testFramework = "utest.runner.Framework"
  }

  // Utilities for replacing text in files
  def replaceBar(args: String*) = Task.Command {
    val relativePath = os.RelPath("../../../foo/src/Bar.scala")
    val filePath = Task.dest() / relativePath
    os.write.over(filePath, os.read(filePath).replace(
      """s"Hi, $name!"""",
      """s"Ciao, $name!""""
    ))
  }

  def replaceFooTest2(args: String*) = Task.Command {
    val relativePath = os.RelPath("../../../foo/test/src/FooTest2.scala")
    val filePath = Task.dest() / relativePath
    os.write.over(filePath, os.read(filePath).replace(
      """assert(greeted == s"Hi, $name!")""",
      """assert(greeted == s"Ciao, $name!")"""
    ))
  }
}

//// SNIPPET:END

/** Usage
> mill -j 1 foo.test.testQuick # First run executes all tests, resulting in 2 passed tests

> cat out/foo/test/testQuick.dest/worker-0/result.log # Result log shows [2,0] indicating 2 passed tests, 0 failed
[2,0]

> mill -j 1 foo.test.testQuick # Second run skips all tests since no code changes were made

> cat out/foo/test/testQuick.dest/worker-0/result.log # Result log shows [0,0] indicating no tests were executed
[0,0]

> mill -j 1 foo.replaceBar # Modify Bar.scala to change greeting from "Hi" to "Ciao"

> mill -j 1 foo.test.testQuick # Third run executes only FooTest2 which fails due to greeting mismatch
error: ...

> cat out/foo/test/testQuick.dest/worker-0/result.log # Result log shows [0,1] indicating 0 passed tests, 1 failed
[0,1]

> mill -j 1 foo.test.testQuick # Fourth run re-runs failing FooTest2 even without code changes
error: ...

> cat out/foo/test/testQuick.dest/worker-0/result.log # Result log shows [0,1] as test continues to fail
[0,1]

> mill -j 1 foo.replaceFooTest2 # Update test assertion to expect "Ciao" instead of "Hi"

> mill -j 1 foo.test.testQuick # Fifth run executes FooTest2 which now passes

> cat out/foo/test/testQuick.dest/worker-0/result.log # Result log shows [1,0] indicating the previously failing test now passes
[1,0]
*/

// In this example, `testQuick` is used to demonstrate fine-grained, change-driven test execution within a module:
//
// - On the first invocation, `mill foo.test.testQuick` executes all test classes in the module and reports the results.
// - If you invoke `testQuick` again without modifying any source files, Mill detects that there are no relevant changes
// and skips test execution entirely.
// - When you update a source file, Mill analyzes the bytecode and determines which test classes are potentially impacted by the change.
// Only those affected tests are executed on the next run.
// - If a test fails, it will continue to be executed on subsequent runs until it passes, regardless of whether further code changes are made.
// - Once the failing test is fixed, and the test passes,
// `testQuick` will again skip running tests unless new changes are detected.
//
// This approach allows you to focus on the tests that matter after each change, minimizing unnecessary test execution and reducing feedback time,
// especially in large or monolithic projects.
